[Back to Main](../main.md)

# Socket Programming

### Concept) Socket
- Desc.)
  - An endpoint for a specific **connection**
  - A **connection** is identified by four things
    - Client IP address
    - Client Port Number
    - Server IP Address
    - Server Port Number
  - A file descriptor use for network communications
- e.g.)
  - Berkeley Socket
    - standard API for network programming available in most OS
    - Written in C
  - POSIX Socket API
    - A slight update of the Berkeley sockets API
- Types)
  - Stream Socket
    - For connection-oriented, point-to-point, reliable byte streams
    - TCP
    - Typically used for client-server communication
  - Datagram Socket
    - For connection-less, one-to-many, unreliable packets
    - UDP
  - Raw Socket

<br><br>

### Concept) Linux Socket Address
- Library
  - `#include <arpa/inet.h>`
- Desc.)
  - Structures, constants, and helper functions used for socket programming
    - Not a class.
      - Why?) C style!
  - Addresses stored in **network byte order** (big endian)
  - Converting between **host** and **network** byte orders:
    - `uint32_t htonl(uint32_t hostlong);`
    - `uint32_t ntohl(uint32_t netlong);`
      - `h` for host byte order
      - `n` for network byte order
      - e.g.) 
        ```cpp
        uint32_t ip = 0xC0A80101; // 192.168.1.1 in hex
        uint32_t net_ip = htonl(ip); // Converts it to big-endian (network order)
        ```
- How to handle both [IPv4](#concept-ipv4) and [IPv6](#concept-ipv6)?
  - Use C structs for each, but make them somewhat similar.
  - Use defined constants to differentiate when to use each:
    - IPv4 : `AF_INET` (=2)
      ```cpp
      // IPv4 4-byte address
      struct in_addr { 
        uint32_t s_addr; // Address in network byte order (big endian)
      };

      // An IPv4-specific address structure
      struct sockaddr_in { 
        sa_family_t sin_family;     // Address family: AF_INET = 2
        in_port_t sin_port;         // Port in network byte order
        struct in_addr sin_addr;    // IPv4 address
        unsigned char sin_zero[8];  // Pad out to 16 bytes
      };
      ```
    - IPv6 : `AF_INET6` (=10)
      ```cpp
      // IPv6 16-byte address
      struct in6_addr {
        uint8_t s6_addr[16]; // Address in network byte order
      };

      // An IPv6-specific address structure
      struct sockaddr_in6 {
        sa_family_t sin6_family; // Address family: AF_INET6 = 10
        in_port_t sin6_port; // Port number
        uint32_t sin6_flowinfo; // IPv6 flow information
        struct in6_addr sin6_addr; // IPv6 address
        uint32_t sin6_scope_id; // Scope ID
      };
      ```
- General Address Structure)
  ```cpp
  struct sockaddr {
    sa_family_t sa_family; // Address family (AF_* constants)
    char sa_data[14];   // Socket address (size varies according to socket domain)
  };

  // A structure big enough to hold either IPv4 or IPv6 structs
  struct sockaddr_storage {
    sa_family_t ss_family;  // Address family

    // padding and alignment; don’t worry about the details
    char __ss_pad1[_SS_PAD1SIZE];
    int64_t __ss_align;
    char __ss_pad2[_SS_PAD2SIZE];
  };
  ```
- Helper Functions)
  - `inet_pton` : Converts string formatted IP into a binary form (`in_addr`, `in6_addr`)
    - e.g.)
      ```cpp
      struct in_addr addr;
      inet_pton(AF_INET, "192.168.1.1", &addr);
      inet_pton(AF_INET6, "2001:db8:63b3:1::3490", &(sa6.sin6_addr));
      ```
  - `inet_ntop` : Reverse `inet_pton`.
    - e.g.)
      ```cpp
      inet_ntop(AF_INET6, &(sa6.sin6_addr), str_var, INET6_ADDRSTRLEN);
      cout << str_var << endl; 
      ```


<br><br>

## Client-Side Socket Programming

### Concept) Socket API: Client TCP Connection
- Five Steps)
  1. Figure out the IP address and port to which to connect
     - POSIX
       - `getaddrinfo()` : Resolve DNS
         ```cpp
         int getaddrinfo(
            const char* hostname, 
            const char* service, 
            const struct addrinfo* hints, 
            struct addrinfo** res   // See below
         )

         struct addrinfo {
             int ai_flags;      // additional flags
             int ai_family;     // AF_INET, AF_INET6, AF_UNSPEC
             int ai_socktype;   // SOCK_STREAM, SOCK_DGRAM, 0
             int ai_protocol;   // IPPROTO_TCP, IPPROTO_UDP, 0
             size_t ai_addrlen; // length of socket addr in bytes
             struct sockaddr* ai_addr; // pointer to socket addr
             char* ai_canonname;       // canonical name
             struct addrinfo* ai_next; // can form a linked list
         }; 
         ```
       - e.g.) `~/upenn_mcit/spring2025/cit5950/scripts/11/dnsresolve.cpp`
  2. Create a socket
     - Syntax)
       ```cpp
       int socket(int domain, int type, int protocol);
       ```
     - Prop.)
       - Returns file descriptor or `-1` on error
     - e.g.)
       ```cpp
       #include <arpa/inet.h>
       #include <stdlib.h>
       #include <string.h>
       #include <unistd.h>
       #include <iostream>

       int main(int argc, char** argv) {
            int socket_fd = socket(AF_INET, SOCK_STREAM, 0);
            if (socket_fd == -1) {
                std::cerr << strerror(errno) << std::endl;
                return EXIT_FAILURE;
            }
            close(socket_fd);
            return EXIT_SUCCESS;
       }
       ```
  3. Connect the socket to the remote server
     - Syntax)
       ```cpp
       int connect(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
       ```
     - Prop.)
       - Returns `0` on success and `-1` on error
       - May take some time to return 
         - It is a blocking call by default (i.e. Waits on an event before returning)
       - e.g.) `~/upenn_mcit/spring2025/cit5950/scripts/11/connect.cpp`
  4. `read()` and `write()` data using the socket
     - cf.)
       - If there is no data waiting for you, by default read() will block until something arrives.
  5. Close the socket
     - Syntax) `close(socket_fd);`





<br><br>

## Server-Side Socket Programming
### Concept) Server
- Props.)
  - Multihoming
    - Can have multiple ip addresses.
    - Home : `127.0.0.1`
  - Goal of server sockets
    - **Bind** the socket to a particular port of one or more IP addresses of the server
    - Allow **multiple** clients to connect to the same port

### Concept) Socket API: Server TCP Connection
- Steps)
  1. Figure out the IP address and port on which to listen*
     - Use `getaddrinfo()`.
     - Even if the machine has a static IP address, don’t wire it into the code.
     - Can request listen on all local IP addresses by... 
       - passing `NULL` as `hostname` 
       - setting `AI_PASSIVE` in `hints.ai_flags`
  2. Create a socket
     - Just like the [client-side socket](#client-side-socket-programming).
     - (Optional) Setting option for the socket.
       ```cpp
       // Configure the socket; we're setting a socket "option."  In
       // particular, we set "SO_REUSEADDR", which tells the TCP stack
       // so make the port we bind to available again as soon as we
       // exit, rather than waiting for a few tens of seconds to recycle it.
       int optval = 1;
       setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));
       ```
  3. `bind()` the socket to the address(es) and port
     - Desc.)
       - Associating, NOT connecting!
       - Returns `0` on success, `-1` on error
     - Syntax)
       ```cpp
       int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
       ```
  4. Tell the socket to `listen()` for incoming clients
     - Desc.)
       - Tells the OS that the socket is a listening socket that clients can connect to.
       - `backlog`: maximum length of connection queue
         - Gets truncated, if necessary, to defined constant `SOMAXCONN`
         - The OS will refuse new connections once queue is full.
           - Until the server `accept()`s them.
       - Returns `0` on success, `-1` on error
     - Client-Server)
       - Clients can start connecting to the socket as soon as `listen()` returns.
       - Server can’t use a connection until you `accept()` it
     - e.g.)
       - `~/upenn_mcit/spring2025/cit5950/scripts/11/server_bind_listen.cpp`
  5. `accept()` a client connection
     - Syntax)
       ```cpp
       int accept(int sockfd, struct sockaddr* addr, socklen_t* addrlen);
       ```
     - Prop.)
       - Returns an active, ready-to-use socket file descriptor connected to a client (or `-1` on error)
     - e.g.)
       - `~/upenn_mcit/spring2025/cit5950/scripts/11/server_accept_rw_close.cpp`
  6. `read()` and `write()` to that connection
     - d
  7. `close()` the client socket
     - d

<br><br>

[Back to Main](../main.md)